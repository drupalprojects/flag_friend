<?php
// $Id$

/**
 * @file flag.module
 * Written by Jerad Bitner (sirkitree.net)
 */

// define our statuses
define('FLAG_FRIEND_BOTH', 0);
define('FLAG_FRIEND_FLAGGED', 1);
define('FLAG_FRIEND_UNFLAGGED', 2);
define('FLAG_FRIEND_APPROVAL', 3);
define('FLAG_FRIEND_PENDING', 4);

/**
 * Implementation of hook_flag().
 */
function flag_friend_flag($event, $flag, $content_id, $account) {
  if ($flag->name == 'friend') {
    if ($event == 'flag') {
      // See the status of the friendship.
      $status = flag_friend_determine_friend_status($flag, $account->uid, $content_id);

      // If both are now flagged, we record the relationship and remove the flags.
      if ($status == FLAG_FRIEND_BOTH) {
        // Remove any message entries for either user.
        flag_friend_message('unflag', $flag, $account->uid, $content_id);
        flag_friend_message('unflag', $flag, $content_id, $account->uid);

        // Since these users have flagged eachother, we create the relationship in the flag_friend table.
        db_query("INSERT INTO {flag_friend} VALUES(%d, %d, %d)", $account->uid, $content_id, $_SERVER['REQUEST_TIME']);

        // Then remove the flags.
        $flag->flag('unflag', $content_id, $account);
        $flag->flag('unflag', $account->uid, user_load(array('uid' => $content_id)));
      }
    }
  }
}

/**
 * Implementation of hook_preprocess_flag().
 */
function flag_friend_preprocess_flag(&$vars) {
  // this hook preprocesses ALL flag links, so make sure we have ours
  if ($vars['flag']->name == 'friend') {
    global $user;

    // Determine what the status in the friend process is.
    $status = flag_friend_determine_friend_status($vars['flag'], $user->uid, $vars['content_id']);
    switch ($status) {
      case FLAG_FRIEND_PENDING:
        $vars['link_text'] = t('Pending - Cancel?');
        $vars['flag_name_css'] = 'pending friend';
        break;

      case FLAG_FRIEND_FLAGGED:
        // Make this link into a remove link with
        $vars['action'] = 'unflag';
        $vars['link_href'] = str_replace('flag/confirm/flag', 'flag/confirm/unfriend', $vars['link_href']);
        $vars['link_text'] = $vars['flag']->unflag_short;
        break;

      case FLAG_FRIEND_APPROVAL:
        $vars['link_text'] = t('Approve');
        break;
    }
  }
}

/**
 * Implementation of hook_perm().
 */
function flag_friend_perm() {
  return array('receive friend email notification');
}

/**
 * Implementation of hook_init().
 */
function flag_friend_init() {
  global $user;
  $flag = flag_get_flag('friend');
  $flags = flag_friend_get_flags($flag, $user->uid);

  // display a status message
  $args[0] = array('user', 'flag');
  $args[2] = array('friends', 'flag');
  if ($count = count($flags) && (!in_array(arg(0), $args[0]) || !in_array(arg(2), $args[2]))) {
    drupal_set_message(l(t('You have !count.', array('!count' => format_plural($count, '1 pending friend request', '@count pending friend requests'))), 'user/'. $user->uid .'/friends'), 'notice');
  }
}

/**
 * Implementation of hook_menu().
 */
function flag_friend_menu() {
  global $user;
  $items = array();
  // menu item to see message and respond
  $items['user/%user/friends'] = array(
    'title' => 'My friends',
    'page callback' => 'flag_friend_page',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Menu callback for displaying friends.
 */
function flag_friend_page($account) {
  global $user;
  $output = '';

  // make sure that only you can see your own pending friends
  if ($user->uid == $account->uid) {
    $flag = flag_get_flag('friend');
    // display a list of any pending friend requests
    $flags = flag_friend_get_flags($flag, $account->uid);
    if (!empty($flags)) {
      $output .= theme('flag_friend_pending_flags', $account, $flags);
    }
  }
  else {
    drupal_set_title(t("@name's friends", array('@name' => $account->name)));
  }

  // display a list of this user's friends
  $friends = flag_friend_get_friends($account->uid);
  $output .= theme('flag_friend_friend_list', $account, $friends);

  return $output;
}

/**
 * Retrieve pending friend flags.
 *
 * @param $flag
 *   The flag object.
 * @param $content_id
 *   The content we're operating on.
 * @param $reset
 *   Boolean trigger to reset the static cache.
 * @return
 *   Array of pending friend flags.
 */
function flag_friend_get_flags($flag, $content_id, $reset = NULL) {
  static $flagged_content;
  $uid = $content_id;
  $content_type = $flag->content_type;

  if (!isset($flagged_content[$uid][$content_type][$content_id]) || $reset) {
    $flags = flag_get_flags($flag->content_type);
    $flagged_content[$uid][$content_type][$content_id] = array();
    // get flags with messages
    $result = db_query("SELECT fc.*, ffm.message FROM {flag_content} fc LEFT JOIN {flag_friend_message} ffm ON ffm.fcid = fc.fcid WHERE content_type = '%s' AND content_id = %d", $content_type, $content_id);
    while ($new_flag = db_fetch_object($result)) {
      $fcid = flag_friend_get_fcid($flag, $content_id, $new_flag->uid);
      $flagged_content[$uid][$content_type][$content_id][$fcid] = $new_flag;
      $flagged_content[$uid][$content_type][$content_id][$fcid]->user = user_load(array('uid' => $new_flag->uid));
    }
  }

  return $flagged_content[$uid][$content_type][$content_id];
}

/**
 * Retrieve a list of friends for the given user.
 *
 * @param $uid
 *   The user id.
 * @param $reset
 *   Boolean trigger to reset the static cache.
 * @return
 *   Array of user objects.
 */
function flag_friend_get_friends($uid, $reset = NULL) {
  static $friends;

  if (!isset($friends[$uid]) || $reset) {
    $result = db_query("SELECT * FROM {flag_friend} WHERE uid = %d OR friend_uid = %d", $uid, $uid);
    while ($friend = db_fetch_object($result)) {
      // if the current user is in the uid column
      if ($friend->uid == $uid) {
        // load the friend_uid
        $friends[$uid][$friend->friend_uid] = user_load(array('uid' => $friend->friend_uid));
      }
      else { // the current user is the friend_uid
        // load the uid column as the friend
        $friends[$uid][$friend->uid] = user_load(array('uid' => $friend->uid));
      }
    }
  }

  return $friends[$uid];
}

/**
 * Theme function for the list of pending flags.
 *
 * @param $account
 *   The user object of the page we're viewing.
 * @param $flags
 *   The list of flags of users who have flagged $account.
 */
function theme_flag_friend_pending_flags($account, $flags) {
  // $flag->user is the user requesting the relationship
  $output = '';
  $output .= t('<h3>You have !friend_request.</h3>', array('!friend_request' => format_plural(count($flags), 'a friend request', count($flags) .' friend requests')));
  $output .= '<dl id="requests" class="accordion">';
  $count = count($flags);
  $output .= '<dt>'. $count .' Pending Friend'. format_plural($count, '', 's') .'</dt>';
  $output .= '<dd><ul>';
  foreach ($flags as $flag) {
    $output .= '<li><div class="user-list"><div class="user clear-block">';
    $output .= '<div class="picture-name"><div class="picture">'. theme('user_picture', $flag->user) .'</div>';
    $output .= '<span class="breakwords">'. theme('username', $flag->user) .'</span></div>';
    $output .= '<div class="info">'. $flag->message .'<br />'. flag_create_link('friend', $flag->user->uid) . flag_friend_create_link('unfriend', $flag->user->uid) .'</div>';
    $output .= '</div></div></li>';
  }
  $output .= '</ul></dd></dl>';

  return $output;
}

/**
 * Theme function for the list of friends for the given user.
 *
 * @param $account
 *   The user object of the user we're displaying friends for.
 * @param $friends
 *   The array of friends for this $account.
 */
function theme_flag_friend_friend_list($account, $friends) {
  global $user;
  $output = '';
  if (!empty($friends)) {
    if ($user->uid == $account->uid) {
      $title = 'My friends';
    }
    else {
      $title = t("@name's friends", array('@name' => $account->name));
    }
    $output .= theme('user_list', $friends, $title);
  }
  else {
    $output .= 'You have no friends, loser.';
  }
  return $output;
}

/**
 * Implementation of hook_user().
 */
function flag_friend_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    case 'form':
      // The user account edit form is about to be displayed. The module should present the form elements it wishes to inject into the form.
      $form = array();
      $form['friend_notification'] = array(
        '#type' => 'select',
        '#title' => t('I would like to be notified when someone wants to be friends with me'),
        '#multiple' => FALSE,
        '#options' => array(0 => 'Yes', -1 => 'No'),
        '#default_value' => isset($account->friend_notification) ? $account->friend_notification : FLAG_FRIEND_NOTIFICATION,
        '#weight' => -10,
      );
      return $form;
      break;
  }
}

/**
 * Create a denial link.
 *
 * @param $type
 *   String to determine what type of link to create.
 * @param $uid
 *   The id of the user we're creating this to flag.
 */
function flag_friend_create_link($type, $uid) {
  if ($type == 'unfriend') {
    $flag = flag_get_flag('friend');
    $link = str_replace('Approve', 'Deny', $flag->theme('unflag', $uid));
    return $link;
  }
}

/**
 * Determines the status of the friendship by testing various conditions.
 *
 * @param $flag
 *   The flag object.
 * @param $uid1
 *   The account id of one of the users.
 * @param $uid2
 *   The account id of the other user.
 * @return
 *   A string describing the status of the relationship.
 * @todo: this could possibly go into hook_flag_access once available.
 */
function flag_friend_determine_friend_status($flag, $uid1, $uid2) {
  static $status_cache = array();
  // always keep these in the same order
  if ($uid1 > $uid2) {
    $key1 = $uid1;
    $key2 = $uid2;
  }
  else {
    $key1 = $uid2;
    $key2 = $uid1;
  }

  if (!isset($status_cache[$key1][$key2])) {
    $you_are_flagged = $flag->is_flagged($uid1, $uid2);
    $they_are_flagged = $flag->is_flagged($uid2, $uid1);
    $friends = db_result(db_query("SELECT * FROM {flag_friend} WHERE (uid = %d AND friend_uid = %d) OR (uid = %d AND friend_uid = %d)", $uid1, $uid2, $uid2, $uid1));
    // see if these users have flagged eachother
    if ($you_are_flagged && $they_are_flagged) {
      $status_cache[$key1][$key2] = FLAG_FRIEND_BOTH;
    }
    elseif ($friends) {
      $status_cache[$key1][$key2] = FLAG_FRIEND_FLAGGED;
    }
    elseif (!$you_are_flagged && !$they_are_flagged) {
      $status_cache[$key1][$key2] = FLAG_FRIEND_UNFLAGGED;
    }
    elseif ($you_are_flagged && !$they_are_flagged) {
      $status_cache[$key1][$key2] = FLAG_FRIEND_APPROVAL;
    }
    elseif (!$you_are_flagged && $they_are_flagged) {
      $status_cache[$key1][$key2] = FLAG_FRIEND_PENDING;
    }
  }
  return $status_cache[$key1][$key2];
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function flag_friend_form_flag_confirm_alter(&$form, &$form_state) {
  if ($form['flag_name']['#value'] == 'friend') {
    $action = $form['action']['#value'];
    $flag = flag_get_flag('friend');
    $content_id = $form['content_id']['#value'];
    $token = $_REQUEST['token'];

    switch ($action) {
      case 'flag':
        $flag_form = flag_friend_message_form($action, $flag, $content_id, $token);
        $form = array_merge($form, $flag_form);
        unset($form['actions']['submit']);
        unset($form['actions']['cancel']);
        $form['#submit'][] = 'flag_friend_form_submit';
        break;
      case 'unflag':
      case 'unfriend':
        $unflag_form = flag_friend_unfriend_form($action, $flag, $content_id, $token);
        $form = array_merge($form, $unflag_form);
        $form['#submit'][] = 'flag_friend_form_submit';
        // switch the order in which we submit so the fcid can still be found
        $form['#submit'] = array_reverse($form['#submit']);
        break;
    }
  }
}

/**
 * Form to send a message to a user before friend flagging.
 */
function flag_friend_message_form($action, $flag, $content_id, $token) {
  $form['current'] = array('#type' => 'value', '#value' => func_get_args());

  $form['flag_friend_message'] = array(
    '#type' => 'textarea',
    '#title' => t('Friend message (optional)'),
    '#description' => t('Enter a message to send to this user.'),
    '#cols' => 60,
    '#rows' => 5,
  );
  $form['flag_friend_submit'] = array(
    '#type' => 'submit',
    '#value' => t('Send'),
    '#suffix' => l('Cancel', $_GET['destination']),
  );
  $form['#theme'] = 'flag_friend_message_form';
  return $form;
}

/**
 * Form to confirm an unfriend flagging.
 */
function flag_friend_unfriend_form($action, $flag, $content_id, $token) {
  $form['current'] = array('#type' => 'value', '#value' => func_get_args());

  $status = flag_friend_determine_friend_status($flag, $user->uid, $content_id);
  switch ($status) {
    case FLAG_FRIEND_PENDING:
      // pending
      $question = t('Are you sure you want to cancel your pending friend request?');
    break;
    case FLAG_FRIEND_APPROVAL:
      // denial
      $question = t('Are you sure you don\'t want to be friends with this user?');
      break;
    default:
      // unfriend
      $question = $flag->get_label('unflag_confirmation', $content_id);
      break;
  }
  $path = $_REQUEST['destination'];
  $form = confirm_form($form, $question, $path);
  $form['#theme'] = 'flag_friend_unfriend_form';
  return $form;
}

/**
 * Submit handler.
 *
 * @see flag_friend_message_form().
 * @see flag_friend_unfriend_form().
 */
function flag_friend_form_submit($form, &$form_state) {
  global $user;
  $action = $form_state['values']['current'][0];
  $flag = $form_state['values']['current'][1];
  $content_id = $form_state['values']['current'][2];
  $token = $form_state['values']['current'][3];
  $status = flag_friend_determine_friend_status($flag, $user->uid, $content_id);
  
  if ($form_state['values']['flag_friend_message']) {
    $flag->friend_message = $form_state['values']['flag_friend_message'];
    // check the status before trying to record.
    // we do this because the flag is removed in hook_flag if this status is
    // true there, which results in an error when trying to save the message
    // because we have no fcid with which to save. so just email it and do note
    // record.
    if ($status !== FLAG_FRIEND_BOTH) {
      flag_friend_message($action, $flag, $content_id, $user->uid);
    }
    flag_friend_message_email($status, $flag, $content_id, $user);
    return;
  }

  flag_friend_unfriend($action, $flag, $content_id, $user, $status);
}

/**
 * Menu callback to either unflag yourself, or remove the relationship record.
 *
 * @param $event
 *   String designator to see what we're doing. (flag, unflag, unfriend)
 * @param $flag_name
 *   The name of the flag, should only be 'friend'.
 * @param $content_id
 *   The id of the content we're operating on. (uid)
 * @param $status
 *   Status integer to see where we are in the friend process.
 */
function flag_friend_unfriend($event, $flag, $content_id, $account, $status) {
  global $user;

  // 'Denial' and 'Pending - Cancel?'
  if ($event == 'unflag') {
    if ($status == FLAG_FRIEND_APPROVAL) {
      // Denial - the content_id is actually the account param in this case
      $account = user_load(array('uid' => $content_id));
      // and the $user->uid is actually the content(_id) we're unflagging
      $content_id = $user->uid;
    }
    // remove any messages
    flag_friend_message($event, $flag, $content_id, $account->uid);
    // unflag
    $flag->flag($event, $content_id, $account);
  }
  else { // event = unfriend
    // remove the friend relationship
    db_query('DELETE FROM {flag_friend} WHERE (uid = %d AND friend_uid = %d) OR (uid = %d AND friend_uid = %d)', $user->uid, $content_id, $content_id, $user->uid);
  }
}

/**
 * API callback function to update our new field.
 */
function flag_friend_message($action, $flag, $content_id, $account_uid) {
  $fcid = flag_friend_get_fcid($flag, $content_id, $account_uid);
  if ($action == 'flag' && $flag->friend_message) {
    db_query("INSERT INTO {flag_friend_message} VALUES(%d, '%s')", $fcid, $flag->friend_message);
  }
  elseif ($action == 'unflag') {
    db_query("DELETE FROM {flag_friend_message} WHERE fcid = %d", $fcid);
  }
}

/**
 * Retrieves the fcid of a flag.
 *
 * NOTE: hopefully fcid will be passed into the hook_flag() at some point
 *       at which time will render this function unnecessary.
 */
function flag_friend_get_fcid($flag, $content_id, $account_uid) {
  return db_result(db_query("SELECT fcid FROM {flag_content} WHERE fid = %d AND content_type = '%s' AND content_id = %d AND uid = %d", $flag->fid, $flag->content_type, $content_id, $account_uid));
}

function flag_friend_message_email($status, $flag, $recipient_uid, $sender) {
  $recipient = user_load(array('uid' => $recipient_uid));
  // if the user can receive notifications
  if (user_access('receive friend email notification')) {
    // and they've expressed they want them
    if ((isset($recipient->friend_notification) && $recipient->friend_notification !== -1) || !isset($recipient->friend_notification)) {
      $email = theme('flag_friend_message_email', $status, $flag, $recipient, $sender);
      if (isset($email['body'])) {
        if (function_exists('messaging_message_send_user')) {
          messaging_message_send_user($recipient, $email, NULL, 1);
        }
        else {
          $language = user_preferred_language($recipient);
          drupal_mail('flag_friend', $email['type'], $recipient->mail, $language, $email);
        }
      }
    }
  }
}

/**
 * Implementation of hook_mail().
 */
function flag_friend_mail($key, &$message, $params) {
  $message['subject'] = $params['subject'];
  $message['body'][] = $params['body'];
}

/**
 * Theme the outgoing email message.
 *
 * @param $status
 *   Status of the friendship.
 * @param $flag
 *   The flag object.
 * @param $recipient
 *   The user object of the person receiving the email.
 * @param $sender
 *   The user object of the person sending the email.
 * @return
 *   An array containing the email [type] (mailkey), [subject] and [body].
 */
function theme_flag_friend_message_email($status, $flag, $recipient, $sender) {
  $email = array();
  $email['type'] = 'flag-friend';

  switch ($status) {
    case FLAG_FRIEND_BOTH:
      // sender confirmed you as a friend
      $email['subject'] = t('!username confirmed you as a friend !site', array(
        '!username' => $sender->name,
        '!site' => 'on '. variable_get('site_name', ''),
        ));
      $email['body'] = t('!firstname confirmed you as a friend on !site.

      To view !firstname\'s profile, follow this link,
      !link

      !message

      Thanks,

      The !site Team', array(
        '!firstname' => $sender->firstname ? $sender->firstname : $sender->name,
        '!site' => variable_get('site_name', ''),
        '!message' => $flag->friend_message ? 'Message:
        '. $flag->friend_message : '',
        '!link' => url('user/'. $sender->uid, array('absolute' => TRUE)),
        ));
      break;

    case FLAG_FRIEND_PENDING:
      // sender added you as a friend
      $email['subject'] = t('!username added you as a friend !site', array('!username' => $sender->name, '!site' => 'on '. variable_get('site_name', '')));
      $email['body'] = t('!firstname added you as a friend on !site. We need to confirm that you know !firstname in order for you to be friends on !site.

      To confirm this friend request, follow the link below:
      !link

      !message

      Thanks,
      The !site Team', array(
        '!firstname' => $sender->firstname ? $sender->firstname : $sender->name,
        '!site' => variable_get('site_name', ''),
        '!message' => $flag->friend_message ? 'Message:
        '. $flag->friend_message : '',
        '!link' => url('user/'. $recipient->uid .'/friends', array('absolute' => TRUE)),
        ));
      break;
  }
  return $email;
}

/**
 * Retrieve our flag's message.
 */
function flag_friend_get_message($fcid) {
  $flag_friend = FALSE;
  $result = db_result(db_query("SELECT message FROM {flag_friend_message} WHERE fcid = %d", $fcid));
  if ($result) {
    $flag_friend = $result;
  }
  return $flag_friend;
}

/**
 * Theme function for the message form.
 */
function theme_flag_friend_message_form($form) {
  return drupal_render($form);
}

/**
 * Theme function for the unfriending action.
 */
function theme_flag_friend_unfriend_form($form) {
  return drupal_render($form);
}

/**
 * Register theme functions.
 */
function flag_friend_theme() {
  return array(
    'flag_friend_pending_flags' => array(
      'arguments' => array('account', 'flags'),
    ),
    'flag_friend_friend_list' => array(
      'arguments' => array('account', 'friends'),
    ),
    'flag_friend_message_email' => array(
      'arguments' => array('status', 'flag', 'recipient', 'sender'),
    ),
     'flag_friend_message_form' => array(
      'arguments' => array('form'),
    ),
     'flag_friend_unfriend_form' => array(
      'arguments' => array('form'),
    ),
  );
}

/**
 * Implementation of hook_flag_default_flags().
 *
 * NOTE: this will not be implemented unless http://drupal.org/node/330141 is
 *       committed to flag.module
 */
function flag_friend_flag_default_flags() {
  $flags = array();
  $flags[] = array(
    'content_type' => 'user',
    'name' => 'friend',
    'title' => 'Friend',
    'roles' => array(
      0 => '2',
    ),
    'global' => FALSE,
    'flag_short' => 'Add friend',
    'flag_long' => 'Add this user to your list of friends.',
    'flag_confirmation' => 'Are you sure you want to add this user to your list of friends?',
    'unflag_short' => 'Remove friend',
    'unflag_long' => 'Remove this user from your list of friends.',
    'unflag_confirmation' => 'Are you sure you want to remove this user from your list of friends?',
    'status' => FALSE,
    'link_type' => 'confirm',
    'locked' => array('name', 'global', 'link_type'),
  );
  return $flags;
}